<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>雷达图</title>
</head>
<body>
<canvas id="canvas" style="background: black" onclick="start()"></canvas>
</body>
<script>

    function start() {
        // let value = 0 // 设置初始值
        // // 创建每一帧渲染之前要执行的方法
        // const add = () => {
        //     requestAnimationFrame(add) // 下一帧渲染之前继续执行 add 方法
        //     value += 0.01*1 // 每帧加数值增加5
        //     translateX = value
        // }
        // requestAnimationFrame(add) // 下一帧渲染之前执行 add 方法
        animate(0, 1, 12400, value => {
            drawCanvas(value)
        }, shake)
    }
    /**
     *  执行补间动画方法
     *
     * @param      {Number}    start     开始数值
     * @param      {Number}    end       结束数值
     * @param      {Number}    time      补间时间
     * @param      {Function}  callback  每帧回调
     * @param      {Function}  easing    缓动方法，默认匀速
     */
    function animate(start, end, time, callback, easing = t => t) {
        let startTime = performance.now() // 设置开始的时间戳
        let differ = end - start // 拿到数值差值
        // 创建每帧之前要执行的函数
        function loop() {
            raf = requestAnimationFrame(loop) // 下一阵调用每帧之前要执行的函数
            const passTime = performance.now() - startTime // 获取当前时间和开始时间差
            let per = passTime / time // 计算当前已过百分比
            if (per >= 1) { // 判读如果已经执行
                per = 1 // 设置为最后的状态
                cancelAnimationFrame(raf) // 停掉动画
            }
            const pass = differ * easing(per) // 通过已过时间百分比*开始结束数值差得出当前的数值
            callback(pass)
        }
        let raf = requestAnimationFrame(loop) // 下一阵调用每帧之前要执行的函数
    }

    function  easeIn(time) { // 接收一个当前的时间占总时间的百分比比
        return time ** 2
    }
    function shake(time) {
        if (time < 0.6) {
            return (time / 0.6) ** 2
        } else {
            return Math.sin((time-0.6) * ((3 * Math.PI) / 0.4)) * 0.2 + 1
        }
    }


    function drawCanvas(translateX) {
        const canvas = document.getElementById("canvas");
        canvas.width = 831;
        canvas.height = 706;
        //绘制的对象获取
        const context = canvas.getContext("2d")
        context.translate(canvas.width / 2, canvas.height / 2)
        context.scale(1, -1)
        context.rotate(translateX)

        //左边一条骨架线段
        context.beginPath();
        let y1 = Math.tan(Math.PI / 180 * 30) * (-300)
        let y2 = Math.tan(Math.PI / 180 * 30) * 300
        context.moveTo(-300, y1)
        context.lineTo(300, y2)
        context.strokeStyle = "rgb(189,142,16)"
        context.stroke()
        context.closePath();


        context.beginPath()
        //中间骨架线
        context.moveTo(0, 300)
        context.lineTo(0, -300)
        context.strokeStyle = "rgb(189,142,16)"
        context.stroke()
        context.closePath();

        //右边一条骨架线段
        context.beginPath()
        let y11 = -Math.tan(Math.PI / 180 * 30) * (-300)
        let y22 = -Math.tan(Math.PI / 180 * 30) * 300
        context.moveTo(-300, y11)
        context.lineTo(300, y22)
        context.strokeStyle = "rgb(189,142,16)"
        context.stroke()
        context.closePath();

        for (let i = 0; i < 6; i++) {
            context.beginPath()
            //绘制圆
            context.arc(0, 0, 50 * (i + 1), 0, Math.PI * 2, true)
            context.strokeStyle = "rgb(189,142,16)"
            context.stroke()
            context.closePath();

        }

        //绘制网线填充
        const datas = [[70*translateX, 100*translateX, 20*translateX, 5*translateX, 21*translateX, 99*translateX], [100*translateX, 120*translateX, 50*translateX, 75*translateX, 121*translateX, 99*translateX], [117*translateX, 211*translateX, 259*translateX, 232*translateX, 190*translateX, 200*translateX], [217*translateX, 240*translateX, 259*translateX, 282*translateX, 190*translateX, 120*translateX]];
        for (let i = 0; i < datas.length; i++) {
            for (let index = 0; index < datas[i].length; index++) {
                context.beginPath()
                //右上角开始顺时针开始绘制
                context.lineTo(datas[i][0] * Math.cos(Math.PI / 180 * 30), datas[i][0] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(datas[i][1] * Math.cos(Math.PI / 180 * 30), -datas[i][1] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(0, -datas[i][2])
                context.lineTo(-datas[i][3] * Math.cos(Math.PI / 180 * 30), -datas[i][3] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(-datas[i][4] * Math.cos(Math.PI / 180 * 30), datas[i][4] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(0, datas[i][5])
                context.fillStyle = "rgba(189,142,16,0.09)"
                context.fill()
                context.closePath();
            }
        }
        //绘制网线边缘线条
        for (let i = 0; i < datas.length; i++) {
            for (let index = 0; index < datas[i].length; index++) {
                context.beginPath()
                //右上角开始顺时针开始绘制
                context.lineTo(datas[i][0] * Math.cos(Math.PI / 180 * 30), datas[i][0] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(datas[i][1] * Math.cos(Math.PI / 180 * 30), -datas[i][1] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(0, -datas[i][2])
                context.lineTo(-datas[i][3] * Math.cos(Math.PI / 180 * 30), -datas[i][3] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(-datas[i][4] * Math.cos(Math.PI / 180 * 30), datas[i][4] * Math.sin(Math.PI / 180 * 30))
                context.lineTo(0, datas[i][5])
                context.strokeStyle = "rgb(189,142,16)"
                context.stroke()
                context.closePath();
            }
        }
    }


</script>
</html>